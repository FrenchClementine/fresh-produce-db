"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/use-product-calendar.ts":
/*!*******************************************!*\
  !*** ./src/hooks/use-product-calendar.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useProductCalendar: () => (/* binding */ useProductCalendar),\n/* harmony export */   useRandomProducts: () => (/* binding */ useRandomProducts)\n/* harmony export */ });\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useProductCalendar,useRandomProducts auto */ \n\nasync function fetchProductCalendarData() {\n    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    let query = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('supplier_product_packaging_spec').select(\"\\n      id,\\n      available_months,\\n      suppliers!inner(\\n        id,\\n        name,\\n        country\\n      ),\\n      product_packaging_specs!inner(\\n        id,\\n        products!inner(\\n          id,\\n          name,\\n          category\\n        ),\\n        packaging_options(\\n          label\\n        ),\\n        size_options(\\n          id,\\n          name\\n        )\\n      )\\n    \").not('available_months', 'is', null).not('suppliers.country', 'is', null);\n    if (filters.searchTerm) {\n        query = query.ilike('product_packaging_specs.products.name', \"%\".concat(filters.searchTerm, \"%\"));\n    }\n    if (filters.category) {\n        query = query.eq('product_packaging_specs.products.category', filters.category);\n    }\n    if (filters.sizeOption) {\n        query = query.eq('product_packaging_specs.size_options.id', filters.sizeOption);\n    }\n    const { data, error } = await query;\n    if (error) throw error;\n    // Process data to group by product and country\n    const processed = new Map();\n    data === null || data === void 0 ? void 0 : data.forEach((item)=>{\n        var _item_product_packaging_specs_packaging_options, _item_product_packaging_specs_size_options;\n        const productId = item.product_packaging_specs.products.id;\n        const productName = item.product_packaging_specs.products.name;\n        const country = item.suppliers.country;\n        const key = \"\".concat(productId, \"-\").concat(country);\n        if (!processed.has(key)) {\n            processed.set(key, {\n                product_id: productId,\n                product_name: productName,\n                country: country,\n                available_months: [],\n                suppliers: []\n            });\n        }\n        const entry = processed.get(key);\n        // Union the available months\n        if (item.available_months) {\n            const newMonths = item.available_months.filter((month)=>!entry.available_months.includes(month));\n            entry.available_months.push(...newMonths);\n        }\n        // Add supplier and spec info\n        let supplier = entry.suppliers.find((s)=>s.id === item.suppliers.id);\n        if (!supplier) {\n            supplier = {\n                id: item.suppliers.id,\n                name: item.suppliers.name,\n                specs: []\n            };\n            entry.suppliers.push(supplier);\n        }\n        supplier.specs.push({\n            id: item.product_packaging_specs.id,\n            packaging_label: ((_item_product_packaging_specs_packaging_options = item.product_packaging_specs.packaging_options) === null || _item_product_packaging_specs_packaging_options === void 0 ? void 0 : _item_product_packaging_specs_packaging_options.label) || 'Unknown',\n            size_name: ((_item_product_packaging_specs_size_options = item.product_packaging_specs.size_options) === null || _item_product_packaging_specs_size_options === void 0 ? void 0 : _item_product_packaging_specs_size_options.name) || 'Unknown',\n            available_months: item.available_months || []\n        });\n    });\n    return Array.from(processed.values()).sort((a, b)=>a.product_name.localeCompare(b.product_name));\n}\nfunction useProductCalendar() {\n    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_1__.useQuery)({\n        queryKey: [\n            'product-calendar',\n            filters\n        ],\n        queryFn: {\n            \"useProductCalendar.useQuery\": ()=>fetchProductCalendarData(filters)\n        }[\"useProductCalendar.useQuery\"],\n        staleTime: 5 * 60 * 1000\n    });\n}\n// Get some random products for default view\nfunction useRandomProducts() {\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_1__.useQuery)({\n        queryKey: [\n            'random-products'\n        ],\n        queryFn: {\n            \"useRandomProducts.useQuery\": async ()=>{\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('products').select('name').eq('is_active', true).limit(3);\n                if (error) throw error;\n                return (data === null || data === void 0 ? void 0 : data.map({\n                    \"useRandomProducts.useQuery\": (p)=>p.name\n                }[\"useRandomProducts.useQuery\"])) || [];\n            }\n        }[\"useRandomProducts.useQuery\"],\n        staleTime: 10 * 60 * 1000\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2UtcHJvZHVjdC1jYWxlbmRhci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OzBGQUVnRDtBQUNQO0FBeUJ6QyxlQUFlRTtRQUF5QkMsVUFBQUEsaUVBQTJCLENBQUM7SUFDbEUsSUFBSUMsUUFBUUgsbURBQVFBLENBQ2pCSSxJQUFJLENBQUMsbUNBQ0xDLE1BQU0sQ0FBRSw0WUF3QlJDLEdBQUcsQ0FBQyxvQkFBb0IsTUFBTSxNQUM5QkEsR0FBRyxDQUFDLHFCQUFxQixNQUFNO0lBRWxDLElBQUlKLFFBQVFLLFVBQVUsRUFBRTtRQUN0QkosUUFBUUEsTUFBTUssS0FBSyxDQUFDLHlDQUF5QyxJQUF1QixPQUFuQk4sUUFBUUssVUFBVSxFQUFDO0lBQ3RGO0lBRUEsSUFBSUwsUUFBUU8sUUFBUSxFQUFFO1FBQ3BCTixRQUFRQSxNQUFNTyxFQUFFLENBQUMsNkNBQTZDUixRQUFRTyxRQUFRO0lBQ2hGO0lBRUEsSUFBSVAsUUFBUVMsVUFBVSxFQUFFO1FBQ3RCUixRQUFRQSxNQUFNTyxFQUFFLENBQUMsMkNBQTJDUixRQUFRUyxVQUFVO0lBQ2hGO0lBRUEsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1WO0lBRTlCLElBQUlVLE9BQU8sTUFBTUE7SUFFakIsK0NBQStDO0lBQy9DLE1BQU1DLFlBQVksSUFBSUM7SUFFdEJILGlCQUFBQSwyQkFBQUEsS0FBTUksT0FBTyxDQUFDLENBQUNDO1lBdUNNQSxpREFDTkE7UUF2Q2IsTUFBTUMsWUFBWUQsS0FBS0UsdUJBQXVCLENBQUNDLFFBQVEsQ0FBQ0MsRUFBRTtRQUMxRCxNQUFNQyxjQUFjTCxLQUFLRSx1QkFBdUIsQ0FBQ0MsUUFBUSxDQUFDRyxJQUFJO1FBQzlELE1BQU1DLFVBQVVQLEtBQUtRLFNBQVMsQ0FBQ0QsT0FBTztRQUN0QyxNQUFNRSxNQUFNLEdBQWdCRixPQUFiTixXQUFVLEtBQVcsT0FBUk07UUFFNUIsSUFBSSxDQUFDVixVQUFVYSxHQUFHLENBQUNELE1BQU07WUFDdkJaLFVBQVVjLEdBQUcsQ0FBQ0YsS0FBSztnQkFDakJHLFlBQVlYO2dCQUNaWSxjQUFjUjtnQkFDZEUsU0FBU0E7Z0JBQ1RPLGtCQUFrQixFQUFFO2dCQUNwQk4sV0FBVyxFQUFFO1lBQ2Y7UUFDRjtRQUVBLE1BQU1PLFFBQVFsQixVQUFVbUIsR0FBRyxDQUFDUDtRQUU1Qiw2QkFBNkI7UUFDN0IsSUFBSVQsS0FBS2MsZ0JBQWdCLEVBQUU7WUFDekIsTUFBTUcsWUFBWWpCLEtBQUtjLGdCQUFnQixDQUFDSSxNQUFNLENBQUMsQ0FBQ0MsUUFDOUMsQ0FBQ0osTUFBTUQsZ0JBQWdCLENBQUNNLFFBQVEsQ0FBQ0Q7WUFFbkNKLE1BQU1ELGdCQUFnQixDQUFDTyxJQUFJLElBQUlKO1FBQ2pDO1FBRUEsNkJBQTZCO1FBQzdCLElBQUlLLFdBQVdQLE1BQU1QLFNBQVMsQ0FBQ2UsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFcEIsRUFBRSxLQUFLSixLQUFLUSxTQUFTLENBQUNKLEVBQUU7UUFDbkUsSUFBSSxDQUFDa0IsVUFBVTtZQUNiQSxXQUFXO2dCQUNUbEIsSUFBSUosS0FBS1EsU0FBUyxDQUFDSixFQUFFO2dCQUNyQkUsTUFBTU4sS0FBS1EsU0FBUyxDQUFDRixJQUFJO2dCQUN6Qm1CLE9BQU8sRUFBRTtZQUNYO1lBQ0FWLE1BQU1QLFNBQVMsQ0FBQ2EsSUFBSSxDQUFDQztRQUN2QjtRQUVBQSxTQUFTRyxLQUFLLENBQUNKLElBQUksQ0FBQztZQUNsQmpCLElBQUlKLEtBQUtFLHVCQUF1QixDQUFDRSxFQUFFO1lBQ25Dc0IsaUJBQWlCMUIsRUFBQUEsa0RBQUFBLEtBQUtFLHVCQUF1QixDQUFDeUIsaUJBQWlCLGNBQTlDM0Isc0VBQUFBLGdEQUFnRDRCLEtBQUssS0FBSTtZQUMxRUMsV0FBVzdCLEVBQUFBLDZDQUFBQSxLQUFLRSx1QkFBdUIsQ0FBQzRCLFlBQVksY0FBekM5QixpRUFBQUEsMkNBQTJDTSxJQUFJLEtBQUk7WUFDOURRLGtCQUFrQmQsS0FBS2MsZ0JBQWdCLElBQUksRUFBRTtRQUMvQztJQUNGO0lBRUEsT0FBT2lCLE1BQU01QyxJQUFJLENBQUNVLFVBQVVtQyxNQUFNLElBQy9CQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRXJCLFlBQVksQ0FBQ3VCLGFBQWEsQ0FBQ0QsRUFBRXRCLFlBQVk7QUFDL0Q7QUFFTyxTQUFTd0I7UUFBbUJwRCxVQUFBQSxpRUFBMkIsQ0FBQztJQUM3RCxPQUFPSCwrREFBUUEsQ0FBQztRQUNkd0QsVUFBVTtZQUFDO1lBQW9CckQ7U0FBUTtRQUN2Q3NELE9BQU87MkNBQUUsSUFBTXZELHlCQUF5QkM7O1FBQ3hDdUQsV0FBVyxJQUFJLEtBQUs7SUFDdEI7QUFDRjtBQUVBLDRDQUE0QztBQUNyQyxTQUFTQztJQUNkLE9BQU8zRCwrREFBUUEsQ0FBQztRQUNkd0QsVUFBVTtZQUFDO1NBQWtCO1FBQzdCQyxPQUFPOzBDQUFFO2dCQUNQLE1BQU0sRUFBRTVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTWIsbURBQVFBLENBQ25DSSxJQUFJLENBQUMsWUFDTEMsTUFBTSxDQUFDLFFBQ1BLLEVBQUUsQ0FBQyxhQUFhLE1BQ2hCaUQsS0FBSyxDQUFDO2dCQUVULElBQUk5QyxPQUFPLE1BQU1BO2dCQUNqQixPQUFPRCxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1nRCxHQUFHO2tEQUFDQyxDQUFBQSxJQUFLQSxFQUFFdEMsSUFBSTtxREFBSyxFQUFFO1lBQ3JDOztRQUNBa0MsV0FBVyxLQUFLLEtBQUs7SUFDdkI7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL29saXZlcmxpdHRsZWNoaWxkL3Byb2R1Y3QgZmluZGVyL2ZyZXNoLXByb2R1Y2UtZGIvc3JjL2hvb2tzL3VzZS1wcm9kdWN0LWNhbGVuZGFyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyB1c2VRdWVyeSB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC1xdWVyeSdcbmltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZHVjdENhbGVuZGFyRGF0YSB7XG4gIHByb2R1Y3RfaWQ6IHN0cmluZ1xuICBwcm9kdWN0X25hbWU6IHN0cmluZ1xuICBjb3VudHJ5OiBzdHJpbmdcbiAgYXZhaWxhYmxlX21vbnRoczogc3RyaW5nW11cbiAgc3VwcGxpZXJzOiBBcnJheTx7XG4gICAgaWQ6IHN0cmluZ1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIHNwZWNzOiBBcnJheTx7XG4gICAgICBpZDogc3RyaW5nXG4gICAgICBwYWNrYWdpbmdfbGFiZWw6IHN0cmluZ1xuICAgICAgc2l6ZV9uYW1lOiBzdHJpbmdcbiAgICAgIGF2YWlsYWJsZV9tb250aHM6IHN0cmluZ1tdXG4gICAgfT5cbiAgfT5cbn1cblxuaW50ZXJmYWNlIENhbGVuZGFyRmlsdGVycyB7XG4gIHNlYXJjaFRlcm0/OiBzdHJpbmdcbiAgY2F0ZWdvcnk/OiBzdHJpbmdcbiAgc2l6ZU9wdGlvbj86IHN0cmluZ1xufVxuXG5hc3luYyBmdW5jdGlvbiBmZXRjaFByb2R1Y3RDYWxlbmRhckRhdGEoZmlsdGVyczogQ2FsZW5kYXJGaWx0ZXJzID0ge30pOiBQcm9taXNlPFByb2R1Y3RDYWxlbmRhckRhdGFbXT4ge1xuICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxuICAgIC5mcm9tKCdzdXBwbGllcl9wcm9kdWN0X3BhY2thZ2luZ19zcGVjJylcbiAgICAuc2VsZWN0KGBcbiAgICAgIGlkLFxuICAgICAgYXZhaWxhYmxlX21vbnRocyxcbiAgICAgIHN1cHBsaWVycyFpbm5lcihcbiAgICAgICAgaWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNvdW50cnlcbiAgICAgICksXG4gICAgICBwcm9kdWN0X3BhY2thZ2luZ19zcGVjcyFpbm5lcihcbiAgICAgICAgaWQsXG4gICAgICAgIHByb2R1Y3RzIWlubmVyKFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY2F0ZWdvcnlcbiAgICAgICAgKSxcbiAgICAgICAgcGFja2FnaW5nX29wdGlvbnMoXG4gICAgICAgICAgbGFiZWxcbiAgICAgICAgKSxcbiAgICAgICAgc2l6ZV9vcHRpb25zKFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKVxuICAgICAgKVxuICAgIGApXG4gICAgLm5vdCgnYXZhaWxhYmxlX21vbnRocycsICdpcycsIG51bGwpXG4gICAgLm5vdCgnc3VwcGxpZXJzLmNvdW50cnknLCAnaXMnLCBudWxsKVxuXG4gIGlmIChmaWx0ZXJzLnNlYXJjaFRlcm0pIHtcbiAgICBxdWVyeSA9IHF1ZXJ5LmlsaWtlKCdwcm9kdWN0X3BhY2thZ2luZ19zcGVjcy5wcm9kdWN0cy5uYW1lJywgYCUke2ZpbHRlcnMuc2VhcmNoVGVybX0lYClcbiAgfVxuXG4gIGlmIChmaWx0ZXJzLmNhdGVnb3J5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS5lcSgncHJvZHVjdF9wYWNrYWdpbmdfc3BlY3MucHJvZHVjdHMuY2F0ZWdvcnknLCBmaWx0ZXJzLmNhdGVnb3J5KVxuICB9XG5cbiAgaWYgKGZpbHRlcnMuc2l6ZU9wdGlvbikge1xuICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3Byb2R1Y3RfcGFja2FnaW5nX3NwZWNzLnNpemVfb3B0aW9ucy5pZCcsIGZpbHRlcnMuc2l6ZU9wdGlvbilcbiAgfVxuXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5XG5cbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gIC8vIFByb2Nlc3MgZGF0YSB0byBncm91cCBieSBwcm9kdWN0IGFuZCBjb3VudHJ5XG4gIGNvbnN0IHByb2Nlc3NlZCA9IG5ldyBNYXA8c3RyaW5nLCBQcm9kdWN0Q2FsZW5kYXJEYXRhPigpXG5cbiAgZGF0YT8uZm9yRWFjaCgoaXRlbTogYW55KSA9PiB7XG4gICAgY29uc3QgcHJvZHVjdElkID0gaXRlbS5wcm9kdWN0X3BhY2thZ2luZ19zcGVjcy5wcm9kdWN0cy5pZFxuICAgIGNvbnN0IHByb2R1Y3ROYW1lID0gaXRlbS5wcm9kdWN0X3BhY2thZ2luZ19zcGVjcy5wcm9kdWN0cy5uYW1lXG4gICAgY29uc3QgY291bnRyeSA9IGl0ZW0uc3VwcGxpZXJzLmNvdW50cnlcbiAgICBjb25zdCBrZXkgPSBgJHtwcm9kdWN0SWR9LSR7Y291bnRyeX1gXG5cbiAgICBpZiAoIXByb2Nlc3NlZC5oYXMoa2V5KSkge1xuICAgICAgcHJvY2Vzc2VkLnNldChrZXksIHtcbiAgICAgICAgcHJvZHVjdF9pZDogcHJvZHVjdElkLFxuICAgICAgICBwcm9kdWN0X25hbWU6IHByb2R1Y3ROYW1lLFxuICAgICAgICBjb3VudHJ5OiBjb3VudHJ5LFxuICAgICAgICBhdmFpbGFibGVfbW9udGhzOiBbXSxcbiAgICAgICAgc3VwcGxpZXJzOiBbXVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBlbnRyeSA9IHByb2Nlc3NlZC5nZXQoa2V5KSFcbiAgICBcbiAgICAvLyBVbmlvbiB0aGUgYXZhaWxhYmxlIG1vbnRoc1xuICAgIGlmIChpdGVtLmF2YWlsYWJsZV9tb250aHMpIHtcbiAgICAgIGNvbnN0IG5ld01vbnRocyA9IGl0ZW0uYXZhaWxhYmxlX21vbnRocy5maWx0ZXIoKG1vbnRoOiBzdHJpbmcpID0+IFxuICAgICAgICAhZW50cnkuYXZhaWxhYmxlX21vbnRocy5pbmNsdWRlcyhtb250aClcbiAgICAgIClcbiAgICAgIGVudHJ5LmF2YWlsYWJsZV9tb250aHMucHVzaCguLi5uZXdNb250aHMpXG4gICAgfVxuXG4gICAgLy8gQWRkIHN1cHBsaWVyIGFuZCBzcGVjIGluZm9cbiAgICBsZXQgc3VwcGxpZXIgPSBlbnRyeS5zdXBwbGllcnMuZmluZChzID0+IHMuaWQgPT09IGl0ZW0uc3VwcGxpZXJzLmlkKVxuICAgIGlmICghc3VwcGxpZXIpIHtcbiAgICAgIHN1cHBsaWVyID0ge1xuICAgICAgICBpZDogaXRlbS5zdXBwbGllcnMuaWQsXG4gICAgICAgIG5hbWU6IGl0ZW0uc3VwcGxpZXJzLm5hbWUsXG4gICAgICAgIHNwZWNzOiBbXVxuICAgICAgfVxuICAgICAgZW50cnkuc3VwcGxpZXJzLnB1c2goc3VwcGxpZXIpXG4gICAgfVxuXG4gICAgc3VwcGxpZXIuc3BlY3MucHVzaCh7XG4gICAgICBpZDogaXRlbS5wcm9kdWN0X3BhY2thZ2luZ19zcGVjcy5pZCxcbiAgICAgIHBhY2thZ2luZ19sYWJlbDogaXRlbS5wcm9kdWN0X3BhY2thZ2luZ19zcGVjcy5wYWNrYWdpbmdfb3B0aW9ucz8ubGFiZWwgfHwgJ1Vua25vd24nLFxuICAgICAgc2l6ZV9uYW1lOiBpdGVtLnByb2R1Y3RfcGFja2FnaW5nX3NwZWNzLnNpemVfb3B0aW9ucz8ubmFtZSB8fCAnVW5rbm93bicsXG4gICAgICBhdmFpbGFibGVfbW9udGhzOiBpdGVtLmF2YWlsYWJsZV9tb250aHMgfHwgW11cbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHByb2Nlc3NlZC52YWx1ZXMoKSlcbiAgICAuc29ydCgoYSwgYikgPT4gYS5wcm9kdWN0X25hbWUubG9jYWxlQ29tcGFyZShiLnByb2R1Y3RfbmFtZSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQcm9kdWN0Q2FsZW5kYXIoZmlsdGVyczogQ2FsZW5kYXJGaWx0ZXJzID0ge30pIHtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogWydwcm9kdWN0LWNhbGVuZGFyJywgZmlsdGVyc10sXG4gICAgcXVlcnlGbjogKCkgPT4gZmV0Y2hQcm9kdWN0Q2FsZW5kYXJEYXRhKGZpbHRlcnMpLFxuICAgIHN0YWxlVGltZTogNSAqIDYwICogMTAwMCwgLy8gNSBtaW51dGVzXG4gIH0pXG59XG5cbi8vIEdldCBzb21lIHJhbmRvbSBwcm9kdWN0cyBmb3IgZGVmYXVsdCB2aWV3XG5leHBvcnQgZnVuY3Rpb24gdXNlUmFuZG9tUHJvZHVjdHMoKSB7XG4gIHJldHVybiB1c2VRdWVyeSh7XG4gICAgcXVlcnlLZXk6IFsncmFuZG9tLXByb2R1Y3RzJ10sXG4gICAgcXVlcnlGbjogYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Byb2R1Y3RzJylcbiAgICAgICAgLnNlbGVjdCgnbmFtZScpXG4gICAgICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcbiAgICAgICAgLmxpbWl0KDMpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIHJldHVybiBkYXRhPy5tYXAocCA9PiBwLm5hbWUpIHx8IFtdXG4gICAgfSxcbiAgICBzdGFsZVRpbWU6IDEwICogNjAgKiAxMDAwLCAvLyAxMCBtaW51dGVzXG4gIH0pXG59Il0sIm5hbWVzIjpbInVzZVF1ZXJ5Iiwic3VwYWJhc2UiLCJmZXRjaFByb2R1Y3RDYWxlbmRhckRhdGEiLCJmaWx0ZXJzIiwicXVlcnkiLCJmcm9tIiwic2VsZWN0Iiwibm90Iiwic2VhcmNoVGVybSIsImlsaWtlIiwiY2F0ZWdvcnkiLCJlcSIsInNpemVPcHRpb24iLCJkYXRhIiwiZXJyb3IiLCJwcm9jZXNzZWQiLCJNYXAiLCJmb3JFYWNoIiwiaXRlbSIsInByb2R1Y3RJZCIsInByb2R1Y3RfcGFja2FnaW5nX3NwZWNzIiwicHJvZHVjdHMiLCJpZCIsInByb2R1Y3ROYW1lIiwibmFtZSIsImNvdW50cnkiLCJzdXBwbGllcnMiLCJrZXkiLCJoYXMiLCJzZXQiLCJwcm9kdWN0X2lkIiwicHJvZHVjdF9uYW1lIiwiYXZhaWxhYmxlX21vbnRocyIsImVudHJ5IiwiZ2V0IiwibmV3TW9udGhzIiwiZmlsdGVyIiwibW9udGgiLCJpbmNsdWRlcyIsInB1c2giLCJzdXBwbGllciIsImZpbmQiLCJzIiwic3BlY3MiLCJwYWNrYWdpbmdfbGFiZWwiLCJwYWNrYWdpbmdfb3B0aW9ucyIsImxhYmVsIiwic2l6ZV9uYW1lIiwic2l6ZV9vcHRpb25zIiwiQXJyYXkiLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwidXNlUHJvZHVjdENhbGVuZGFyIiwicXVlcnlLZXkiLCJxdWVyeUZuIiwic3RhbGVUaW1lIiwidXNlUmFuZG9tUHJvZHVjdHMiLCJsaW1pdCIsIm1hcCIsInAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-product-calendar.ts\n"));

/***/ })

});