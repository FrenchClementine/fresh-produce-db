"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/use-product-calendar.ts":
/*!*******************************************!*\
  !*** ./src/hooks/use-product-calendar.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useActiveCertifications: () => (/* binding */ useActiveCertifications),\n/* harmony export */   useProductCalendar: () => (/* binding */ useProductCalendar),\n/* harmony export */   useProductCategories: () => (/* binding */ useProductCategories),\n/* harmony export */   useRandomProducts: () => (/* binding */ useRandomProducts),\n/* harmony export */   useSizeOptions: () => (/* binding */ useSizeOptions)\n/* harmony export */ });\n/* harmony import */ var _tanstack_react_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/react-query */ \"(app-pages-browser)/./node_modules/@tanstack/react-query/build/modern/useQuery.js\");\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ useProductCalendar,useRandomProducts,useProductCategories,useSizeOptions,useActiveCertifications auto */ \n\nasync function fetchProductCalendarData() {\n    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    let query = _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('supplier_product_packaging_spec').select(\"\\n      id,\\n      available_months,\\n      suppliers!inner(\\n        id,\\n        name,\\n        country\\n      ),\\n      product_packaging_specs!inner(\\n        id,\\n        products!inner(\\n          id,\\n          name,\\n          category\\n        ),\\n        packaging_options(\\n          label\\n        ),\\n        size_options(\\n          id,\\n          name\\n        )\\n      )\\n    \").not('available_months', 'is', null).not('suppliers.country', 'is', null);\n    // When filtering by certification, we need to join with supplier_certifications\n    if (filters.certificationId) {\n        // We need to modify the query to include certification filter\n        // This requires a different approach since we need to filter suppliers by their certifications\n        const { data: supplierIds, error: certError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('supplier_certifications').select('supplier_id').eq('certification_id', filters.certificationId);\n        if (certError) throw certError;\n        const validSupplierIds = (supplierIds === null || supplierIds === void 0 ? void 0 : supplierIds.map((s)=>s.supplier_id)) || [];\n        if (validSupplierIds.length === 0) {\n            // No suppliers have this certification, return empty array\n            return [];\n        }\n        query = query.in('supplier_id', validSupplierIds);\n    }\n    if (filters.searchTerm) {\n        query = query.ilike('product_packaging_specs.products.name', \"%\".concat(filters.searchTerm, \"%\"));\n    }\n    if (filters.category) {\n        query = query.eq('product_packaging_specs.products.category', filters.category);\n    }\n    if (filters.sizeOption) {\n        query = query.eq('product_packaging_specs.size_options.id', filters.sizeOption);\n    }\n    const { data, error } = await query;\n    if (error) throw error;\n    // Process data to group by product and country\n    const processed = new Map();\n    data === null || data === void 0 ? void 0 : data.forEach((item)=>{\n        var _item_product_packaging_specs_packaging_options, _item_product_packaging_specs_size_options;\n        const productId = item.product_packaging_specs.products.id;\n        const productName = item.product_packaging_specs.products.name;\n        const country = item.suppliers.country;\n        const key = \"\".concat(productId, \"-\").concat(country);\n        if (!processed.has(key)) {\n            processed.set(key, {\n                product_id: productId,\n                product_name: productName,\n                country: country,\n                available_months: [],\n                suppliers: []\n            });\n        }\n        const entry = processed.get(key);\n        // Union the available months\n        if (item.available_months) {\n            const newMonths = item.available_months.filter((month)=>!entry.available_months.includes(month));\n            entry.available_months.push(...newMonths);\n        }\n        // Add supplier and spec info\n        let supplier = entry.suppliers.find((s)=>s.id === item.suppliers.id);\n        if (!supplier) {\n            supplier = {\n                id: item.suppliers.id,\n                name: item.suppliers.name,\n                specs: []\n            };\n            entry.suppliers.push(supplier);\n        }\n        supplier.specs.push({\n            id: item.product_packaging_specs.id,\n            packaging_label: ((_item_product_packaging_specs_packaging_options = item.product_packaging_specs.packaging_options) === null || _item_product_packaging_specs_packaging_options === void 0 ? void 0 : _item_product_packaging_specs_packaging_options.label) || 'Unknown',\n            size_name: ((_item_product_packaging_specs_size_options = item.product_packaging_specs.size_options) === null || _item_product_packaging_specs_size_options === void 0 ? void 0 : _item_product_packaging_specs_size_options.name) || 'Unknown',\n            available_months: item.available_months || []\n        });\n    });\n    return Array.from(processed.values()).sort((a, b)=>a.product_name.localeCompare(b.product_name));\n}\nfunction useProductCalendar() {\n    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_1__.useQuery)({\n        queryKey: [\n            'product-calendar',\n            filters\n        ],\n        queryFn: {\n            \"useProductCalendar.useQuery\": ()=>fetchProductCalendarData(filters)\n        }[\"useProductCalendar.useQuery\"],\n        staleTime: 5 * 60 * 1000\n    });\n}\n// Get some random products for default view\nfunction useRandomProducts() {\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_1__.useQuery)({\n        queryKey: [\n            'random-products'\n        ],\n        queryFn: {\n            \"useRandomProducts.useQuery\": async ()=>{\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('products').select('name').eq('is_active', true).limit(3);\n                if (error) throw error;\n                return (data === null || data === void 0 ? void 0 : data.map({\n                    \"useRandomProducts.useQuery\": (p)=>p.name\n                }[\"useRandomProducts.useQuery\"])) || [];\n            }\n        }[\"useRandomProducts.useQuery\"],\n        staleTime: 10 * 60 * 1000\n    });\n}\n// Get available product categories for filtering\nfunction useProductCategories() {\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_1__.useQuery)({\n        queryKey: [\n            'product-categories'\n        ],\n        queryFn: {\n            \"useProductCategories.useQuery\": async ()=>{\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('products').select('category').eq('is_active', true);\n                if (error) throw error;\n                // Get unique categories\n                const categories = [\n                    ...new Set((data === null || data === void 0 ? void 0 : data.map({\n                        \"useProductCategories.useQuery\": (p)=>p.category\n                    }[\"useProductCategories.useQuery\"])) || [])\n                ];\n                return categories.sort();\n            }\n        }[\"useProductCategories.useQuery\"],\n        staleTime: 10 * 60 * 1000\n    });\n}\n// Get available size options for filtering\nfunction useSizeOptions() {\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_1__.useQuery)({\n        queryKey: [\n            'size-options-filter'\n        ],\n        queryFn: {\n            \"useSizeOptions.useQuery\": async ()=>{\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('size_options').select('id, name').order('name');\n                if (error) throw error;\n                return data || [];\n            }\n        }[\"useSizeOptions.useQuery\"],\n        staleTime: 10 * 60 * 1000\n    });\n}\n// Get certifications that are actively used by suppliers for filtering\nfunction useActiveCertifications() {\n    return (0,_tanstack_react_query__WEBPACK_IMPORTED_MODULE_1__.useQuery)({\n        queryKey: [\n            'active-certifications'\n        ],\n        queryFn: {\n            \"useActiveCertifications.useQuery\": async ()=>{\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('supplier_certifications').select(\"\\n          certifications:certification_id(\\n            id,\\n            name\\n          )\\n        \").not('certifications', 'is', null);\n                if (error) throw error;\n                // Extract unique certifications\n                const uniqueCertifications = new Map();\n                data === null || data === void 0 ? void 0 : data.forEach({\n                    \"useActiveCertifications.useQuery\": (item)=>{\n                        if (item.certifications) {\n                            uniqueCertifications.set(item.certifications.id, item.certifications);\n                        }\n                    }\n                }[\"useActiveCertifications.useQuery\"]);\n                return Array.from(uniqueCertifications.values()).sort({\n                    \"useActiveCertifications.useQuery\": (a, b)=>a.name.localeCompare(b.name)\n                }[\"useActiveCertifications.useQuery\"]);\n            }\n        }[\"useActiveCertifications.useQuery\"],\n        staleTime: 10 * 60 * 1000\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2UtcHJvZHVjdC1jYWxlbmRhci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O3NKQUVnRDtBQUNQO0FBMEJ6QyxlQUFlRTtRQUF5QkMsVUFBQUEsaUVBQTJCLENBQUM7SUFDbEUsSUFBSUMsUUFBUUgsbURBQVFBLENBQ2pCSSxJQUFJLENBQUMsbUNBQ0xDLE1BQU0sQ0FBRSw0WUF3QlJDLEdBQUcsQ0FBQyxvQkFBb0IsTUFBTSxNQUM5QkEsR0FBRyxDQUFDLHFCQUFxQixNQUFNO0lBRWxDLGdGQUFnRjtJQUNoRixJQUFJSixRQUFRSyxlQUFlLEVBQUU7UUFDM0IsOERBQThEO1FBQzlELCtGQUErRjtRQUMvRixNQUFNLEVBQUVDLE1BQU1DLFdBQVcsRUFBRUMsT0FBT0MsU0FBUyxFQUFFLEdBQUcsTUFBTVgsbURBQVFBLENBQzNESSxJQUFJLENBQUMsMkJBQ0xDLE1BQU0sQ0FBQyxlQUNQTyxFQUFFLENBQUMsb0JBQW9CVixRQUFRSyxlQUFlO1FBRWpELElBQUlJLFdBQVcsTUFBTUE7UUFFckIsTUFBTUUsbUJBQW1CSixDQUFBQSx3QkFBQUEsa0NBQUFBLFlBQWFLLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsV0FBVyxNQUFLLEVBQUU7UUFDbkUsSUFBSUgsaUJBQWlCSSxNQUFNLEtBQUssR0FBRztZQUNqQywyREFBMkQ7WUFDM0QsT0FBTyxFQUFFO1FBQ1g7UUFFQWQsUUFBUUEsTUFBTWUsRUFBRSxDQUFDLGVBQWVMO0lBQ2xDO0lBRUEsSUFBSVgsUUFBUWlCLFVBQVUsRUFBRTtRQUN0QmhCLFFBQVFBLE1BQU1pQixLQUFLLENBQUMseUNBQXlDLElBQXVCLE9BQW5CbEIsUUFBUWlCLFVBQVUsRUFBQztJQUN0RjtJQUVBLElBQUlqQixRQUFRbUIsUUFBUSxFQUFFO1FBQ3BCbEIsUUFBUUEsTUFBTVMsRUFBRSxDQUFDLDZDQUE2Q1YsUUFBUW1CLFFBQVE7SUFDaEY7SUFFQSxJQUFJbkIsUUFBUW9C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O1FBQ0F5RCxXQUFXLEtBQUssS0FBSztJQUN2QjtBQUNGO0FBRUEsdUVBQXVFO0FBQ2hFLFNBQVNTO0lBQ2QsT0FBTzNFLCtEQUFRQSxDQUFDO1FBQ2RnRSxVQUFVO1lBQUM7U0FBd0I7UUFDbkNDLE9BQU87Z0RBQUU7Z0JBQ1AsTUFBTSxFQUFFeEQsSUFBSSxFQUFFRSxLQUFLLEVBQUUsR0FBRyxNQUFNVixtREFBUUEsQ0FDbkNJLElBQUksQ0FBQywyQkFDTEMsTUFBTSxDQUFFLDBHQU1SQyxHQUFHLENBQUMsa0JBQWtCLE1BQU07Z0JBRS9CLElBQUlJLE9BQU8sTUFBTUE7Z0JBRWpCLGdDQUFnQztnQkFDaEMsTUFBTWlFLHVCQUF1QixJQUFJbkQ7Z0JBQ2pDaEIsaUJBQUFBLDJCQUFBQSxLQUFNaUIsT0FBTzt3REFBQyxDQUFDQzt3QkFDYixJQUFJQSxLQUFLa0QsY0FBYyxFQUFFOzRCQUN2QkQscUJBQXFCdEMsR0FBRyxDQUFDWCxLQUFLa0QsY0FBYyxDQUFDOUMsRUFBRSxFQUFFSixLQUFLa0QsY0FBYzt3QkFDdEU7b0JBQ0Y7O2dCQUVBLE9BQU9wQixNQUFNcEQsSUFBSSxDQUFDdUUscUJBQXFCbEIsTUFBTSxJQUFJQyxJQUFJO3dEQUFDLENBQUNDLEdBQVFDLElBQVdELEVBQUUzQixJQUFJLENBQUM2QixhQUFhLENBQUNELEVBQUU1QixJQUFJOztZQUN2Rzs7UUFDQWlDLFdBQVcsS0FBSyxLQUFLO0lBQ3ZCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9vbGl2ZXJsaXR0bGVjaGlsZC9wcm9kdWN0IGZpbmRlci9mcmVzaC1wcm9kdWNlLWRiL3NyYy9ob29rcy91c2UtcHJvZHVjdC1jYWxlbmRhci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlUXVlcnkgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknXG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb2R1Y3RDYWxlbmRhckRhdGEge1xuICBwcm9kdWN0X2lkOiBzdHJpbmdcbiAgcHJvZHVjdF9uYW1lOiBzdHJpbmdcbiAgY291bnRyeTogc3RyaW5nXG4gIGF2YWlsYWJsZV9tb250aHM6IHN0cmluZ1tdXG4gIHN1cHBsaWVyczogQXJyYXk8e1xuICAgIGlkOiBzdHJpbmdcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBzcGVjczogQXJyYXk8e1xuICAgICAgaWQ6IHN0cmluZ1xuICAgICAgcGFja2FnaW5nX2xhYmVsOiBzdHJpbmdcbiAgICAgIHNpemVfbmFtZTogc3RyaW5nXG4gICAgICBhdmFpbGFibGVfbW9udGhzOiBzdHJpbmdbXVxuICAgIH0+XG4gIH0+XG59XG5cbmludGVyZmFjZSBDYWxlbmRhckZpbHRlcnMge1xuICBzZWFyY2hUZXJtPzogc3RyaW5nXG4gIGNhdGVnb3J5Pzogc3RyaW5nXG4gIHNpemVPcHRpb24/OiBzdHJpbmdcbiAgY2VydGlmaWNhdGlvbklkPzogc3RyaW5nXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUHJvZHVjdENhbGVuZGFyRGF0YShmaWx0ZXJzOiBDYWxlbmRhckZpbHRlcnMgPSB7fSk6IFByb21pc2U8UHJvZHVjdENhbGVuZGFyRGF0YVtdPiB7XG4gIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgLmZyb20oJ3N1cHBsaWVyX3Byb2R1Y3RfcGFja2FnaW5nX3NwZWMnKVxuICAgIC5zZWxlY3QoYFxuICAgICAgaWQsXG4gICAgICBhdmFpbGFibGVfbW9udGhzLFxuICAgICAgc3VwcGxpZXJzIWlubmVyKFxuICAgICAgICBpZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY291bnRyeVxuICAgICAgKSxcbiAgICAgIHByb2R1Y3RfcGFja2FnaW5nX3NwZWNzIWlubmVyKFxuICAgICAgICBpZCxcbiAgICAgICAgcHJvZHVjdHMhaW5uZXIoXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjYXRlZ29yeVxuICAgICAgICApLFxuICAgICAgICBwYWNrYWdpbmdfb3B0aW9ucyhcbiAgICAgICAgICBsYWJlbFxuICAgICAgICApLFxuICAgICAgICBzaXplX29wdGlvbnMoXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbmFtZVxuICAgICAgICApXG4gICAgICApXG4gICAgYClcbiAgICAubm90KCdhdmFpbGFibGVfbW9udGhzJywgJ2lzJywgbnVsbClcbiAgICAubm90KCdzdXBwbGllcnMuY291bnRyeScsICdpcycsIG51bGwpXG5cbiAgLy8gV2hlbiBmaWx0ZXJpbmcgYnkgY2VydGlmaWNhdGlvbiwgd2UgbmVlZCB0byBqb2luIHdpdGggc3VwcGxpZXJfY2VydGlmaWNhdGlvbnNcbiAgaWYgKGZpbHRlcnMuY2VydGlmaWNhdGlvbklkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBtb2RpZnkgdGhlIHF1ZXJ5IHRvIGluY2x1ZGUgY2VydGlmaWNhdGlvbiBmaWx0ZXJcbiAgICAvLyBUaGlzIHJlcXVpcmVzIGEgZGlmZmVyZW50IGFwcHJvYWNoIHNpbmNlIHdlIG5lZWQgdG8gZmlsdGVyIHN1cHBsaWVycyBieSB0aGVpciBjZXJ0aWZpY2F0aW9uc1xuICAgIGNvbnN0IHsgZGF0YTogc3VwcGxpZXJJZHMsIGVycm9yOiBjZXJ0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnc3VwcGxpZXJfY2VydGlmaWNhdGlvbnMnKVxuICAgICAgLnNlbGVjdCgnc3VwcGxpZXJfaWQnKVxuICAgICAgLmVxKCdjZXJ0aWZpY2F0aW9uX2lkJywgZmlsdGVycy5jZXJ0aWZpY2F0aW9uSWQpXG5cbiAgICBpZiAoY2VydEVycm9yKSB0aHJvdyBjZXJ0RXJyb3JcblxuICAgIGNvbnN0IHZhbGlkU3VwcGxpZXJJZHMgPSBzdXBwbGllcklkcz8ubWFwKHMgPT4gcy5zdXBwbGllcl9pZCkgfHwgW11cbiAgICBpZiAodmFsaWRTdXBwbGllcklkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIHN1cHBsaWVycyBoYXZlIHRoaXMgY2VydGlmaWNhdGlvbiwgcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBxdWVyeSA9IHF1ZXJ5LmluKCdzdXBwbGllcl9pZCcsIHZhbGlkU3VwcGxpZXJJZHMpXG4gIH1cblxuICBpZiAoZmlsdGVycy5zZWFyY2hUZXJtKSB7XG4gICAgcXVlcnkgPSBxdWVyeS5pbGlrZSgncHJvZHVjdF9wYWNrYWdpbmdfc3BlY3MucHJvZHVjdHMubmFtZScsIGAlJHtmaWx0ZXJzLnNlYXJjaFRlcm19JWApXG4gIH1cblxuICBpZiAoZmlsdGVycy5jYXRlZ29yeSkge1xuICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3Byb2R1Y3RfcGFja2FnaW5nX3NwZWNzLnByb2R1Y3RzLmNhdGVnb3J5JywgZmlsdGVycy5jYXRlZ29yeSlcbiAgfVxuXG4gIGlmIChmaWx0ZXJzLnNpemVPcHRpb24pIHtcbiAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdwcm9kdWN0X3BhY2thZ2luZ19zcGVjcy5zaXplX29wdGlvbnMuaWQnLCBmaWx0ZXJzLnNpemVPcHRpb24pXG4gIH1cblxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeVxuXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAvLyBQcm9jZXNzIGRhdGEgdG8gZ3JvdXAgYnkgcHJvZHVjdCBhbmQgY291bnRyeVxuICBjb25zdCBwcm9jZXNzZWQgPSBuZXcgTWFwPHN0cmluZywgUHJvZHVjdENhbGVuZGFyRGF0YT4oKVxuXG4gIGRhdGE/LmZvckVhY2goKGl0ZW06IGFueSkgPT4ge1xuICAgIGNvbnN0IHByb2R1Y3RJZCA9IGl0ZW0ucHJvZHVjdF9wYWNrYWdpbmdfc3BlY3MucHJvZHVjdHMuaWRcbiAgICBjb25zdCBwcm9kdWN0TmFtZSA9IGl0ZW0ucHJvZHVjdF9wYWNrYWdpbmdfc3BlY3MucHJvZHVjdHMubmFtZVxuICAgIGNvbnN0IGNvdW50cnkgPSBpdGVtLnN1cHBsaWVycy5jb3VudHJ5XG4gICAgY29uc3Qga2V5ID0gYCR7cHJvZHVjdElkfS0ke2NvdW50cnl9YFxuXG4gICAgaWYgKCFwcm9jZXNzZWQuaGFzKGtleSkpIHtcbiAgICAgIHByb2Nlc3NlZC5zZXQoa2V5LCB7XG4gICAgICAgIHByb2R1Y3RfaWQ6IHByb2R1Y3RJZCxcbiAgICAgICAgcHJvZHVjdF9uYW1lOiBwcm9kdWN0TmFtZSxcbiAgICAgICAgY291bnRyeTogY291bnRyeSxcbiAgICAgICAgYXZhaWxhYmxlX21vbnRoczogW10sXG4gICAgICAgIHN1cHBsaWVyczogW11cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgZW50cnkgPSBwcm9jZXNzZWQuZ2V0KGtleSkhXG4gICAgXG4gICAgLy8gVW5pb24gdGhlIGF2YWlsYWJsZSBtb250aHNcbiAgICBpZiAoaXRlbS5hdmFpbGFibGVfbW9udGhzKSB7XG4gICAgICBjb25zdCBuZXdNb250aHMgPSBpdGVtLmF2YWlsYWJsZV9tb250aHMuZmlsdGVyKChtb250aDogc3RyaW5nKSA9PiBcbiAgICAgICAgIWVudHJ5LmF2YWlsYWJsZV9tb250aHMuaW5jbHVkZXMobW9udGgpXG4gICAgICApXG4gICAgICBlbnRyeS5hdmFpbGFibGVfbW9udGhzLnB1c2goLi4ubmV3TW9udGhzKVxuICAgIH1cblxuICAgIC8vIEFkZCBzdXBwbGllciBhbmQgc3BlYyBpbmZvXG4gICAgbGV0IHN1cHBsaWVyID0gZW50cnkuc3VwcGxpZXJzLmZpbmQocyA9PiBzLmlkID09PSBpdGVtLnN1cHBsaWVycy5pZClcbiAgICBpZiAoIXN1cHBsaWVyKSB7XG4gICAgICBzdXBwbGllciA9IHtcbiAgICAgICAgaWQ6IGl0ZW0uc3VwcGxpZXJzLmlkLFxuICAgICAgICBuYW1lOiBpdGVtLnN1cHBsaWVycy5uYW1lLFxuICAgICAgICBzcGVjczogW11cbiAgICAgIH1cbiAgICAgIGVudHJ5LnN1cHBsaWVycy5wdXNoKHN1cHBsaWVyKVxuICAgIH1cblxuICAgIHN1cHBsaWVyLnNwZWNzLnB1c2goe1xuICAgICAgaWQ6IGl0ZW0ucHJvZHVjdF9wYWNrYWdpbmdfc3BlY3MuaWQsXG4gICAgICBwYWNrYWdpbmdfbGFiZWw6IGl0ZW0ucHJvZHVjdF9wYWNrYWdpbmdfc3BlY3MucGFja2FnaW5nX29wdGlvbnM/LmxhYmVsIHx8ICdVbmtub3duJyxcbiAgICAgIHNpemVfbmFtZTogaXRlbS5wcm9kdWN0X3BhY2thZ2luZ19zcGVjcy5zaXplX29wdGlvbnM/Lm5hbWUgfHwgJ1Vua25vd24nLFxuICAgICAgYXZhaWxhYmxlX21vbnRoczogaXRlbS5hdmFpbGFibGVfbW9udGhzIHx8IFtdXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gQXJyYXkuZnJvbShwcm9jZXNzZWQudmFsdWVzKCkpXG4gICAgLnNvcnQoKGEsIGIpID0+IGEucHJvZHVjdF9uYW1lLmxvY2FsZUNvbXBhcmUoYi5wcm9kdWN0X25hbWUpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJvZHVjdENhbGVuZGFyKGZpbHRlcnM6IENhbGVuZGFyRmlsdGVycyA9IHt9KSB7XG4gIHJldHVybiB1c2VRdWVyeSh7XG4gICAgcXVlcnlLZXk6IFsncHJvZHVjdC1jYWxlbmRhcicsIGZpbHRlcnNdLFxuICAgIHF1ZXJ5Rm46ICgpID0+IGZldGNoUHJvZHVjdENhbGVuZGFyRGF0YShmaWx0ZXJzKSxcbiAgICBzdGFsZVRpbWU6IDUgKiA2MCAqIDEwMDAsIC8vIDUgbWludXRlc1xuICB9KVxufVxuXG4vLyBHZXQgc29tZSByYW5kb20gcHJvZHVjdHMgZm9yIGRlZmF1bHQgdmlld1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhbmRvbVByb2R1Y3RzKCkge1xuICByZXR1cm4gdXNlUXVlcnkoe1xuICAgIHF1ZXJ5S2V5OiBbJ3JhbmRvbS1wcm9kdWN0cyddLFxuICAgIHF1ZXJ5Rm46IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwcm9kdWN0cycpXG4gICAgICAgIC5zZWxlY3QoJ25hbWUnKVxuICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG4gICAgICAgIC5saW1pdCgzKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICByZXR1cm4gZGF0YT8ubWFwKHAgPT4gcC5uYW1lKSB8fCBbXVxuICAgIH0sXG4gICAgc3RhbGVUaW1lOiAxMCAqIDYwICogMTAwMCwgLy8gMTAgbWludXRlc1xuICB9KVxufVxuXG4vLyBHZXQgYXZhaWxhYmxlIHByb2R1Y3QgY2F0ZWdvcmllcyBmb3IgZmlsdGVyaW5nXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJvZHVjdENhdGVnb3JpZXMoKSB7XG4gIHJldHVybiB1c2VRdWVyeSh7XG4gICAgcXVlcnlLZXk6IFsncHJvZHVjdC1jYXRlZ29yaWVzJ10sXG4gICAgcXVlcnlGbjogYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3Byb2R1Y3RzJylcbiAgICAgICAgLnNlbGVjdCgnY2F0ZWdvcnknKVxuICAgICAgICAuZXEoJ2lzX2FjdGl2ZScsIHRydWUpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIFxuICAgICAgLy8gR2V0IHVuaXF1ZSBjYXRlZ29yaWVzXG4gICAgICBjb25zdCBjYXRlZ29yaWVzID0gWy4uLm5ldyBTZXQoZGF0YT8ubWFwKHAgPT4gcC5jYXRlZ29yeSkgfHwgW10pXVxuICAgICAgcmV0dXJuIGNhdGVnb3JpZXMuc29ydCgpXG4gICAgfSxcbiAgICBzdGFsZVRpbWU6IDEwICogNjAgKiAxMDAwLCAvLyAxMCBtaW51dGVzXG4gIH0pXG59XG5cbi8vIEdldCBhdmFpbGFibGUgc2l6ZSBvcHRpb25zIGZvciBmaWx0ZXJpbmdcbmV4cG9ydCBmdW5jdGlvbiB1c2VTaXplT3B0aW9ucygpIHtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogWydzaXplLW9wdGlvbnMtZmlsdGVyJ10sXG4gICAgcXVlcnlGbjogYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NpemVfb3B0aW9ucycpXG4gICAgICAgIC5zZWxlY3QoJ2lkLCBuYW1lJylcbiAgICAgICAgLm9yZGVyKCduYW1lJylcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgcmV0dXJuIGRhdGEgfHwgW11cbiAgICB9LFxuICAgIHN0YWxlVGltZTogMTAgKiA2MCAqIDEwMDAsIC8vIDEwIG1pbnV0ZXNcbiAgfSlcbn1cblxuLy8gR2V0IGNlcnRpZmljYXRpb25zIHRoYXQgYXJlIGFjdGl2ZWx5IHVzZWQgYnkgc3VwcGxpZXJzIGZvciBmaWx0ZXJpbmdcbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3RpdmVDZXJ0aWZpY2F0aW9ucygpIHtcbiAgcmV0dXJuIHVzZVF1ZXJ5KHtcbiAgICBxdWVyeUtleTogWydhY3RpdmUtY2VydGlmaWNhdGlvbnMnXSxcbiAgICBxdWVyeUZuOiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc3VwcGxpZXJfY2VydGlmaWNhdGlvbnMnKVxuICAgICAgICAuc2VsZWN0KGBcbiAgICAgICAgICBjZXJ0aWZpY2F0aW9uczpjZXJ0aWZpY2F0aW9uX2lkKFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgKVxuICAgICAgICBgKVxuICAgICAgICAubm90KCdjZXJ0aWZpY2F0aW9ucycsICdpcycsIG51bGwpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCB1bmlxdWUgY2VydGlmaWNhdGlvbnNcbiAgICAgIGNvbnN0IHVuaXF1ZUNlcnRpZmljYXRpb25zID0gbmV3IE1hcCgpXG4gICAgICBkYXRhPy5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKGl0ZW0uY2VydGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICB1bmlxdWVDZXJ0aWZpY2F0aW9ucy5zZXQoaXRlbS5jZXJ0aWZpY2F0aW9ucy5pZCwgaXRlbS5jZXJ0aWZpY2F0aW9ucylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgcmV0dXJuIEFycmF5LmZyb20odW5pcXVlQ2VydGlmaWNhdGlvbnMudmFsdWVzKCkpLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpKVxuICAgIH0sXG4gICAgc3RhbGVUaW1lOiAxMCAqIDYwICogMTAwMCwgLy8gMTAgbWludXRlc1xuICB9KVxufVxuXG4vLyBFeHBvcnQgdGhlIGludGVyZmFjZSBmb3IgdXNlIGluIGNvbXBvbmVudHNcbmV4cG9ydCB0eXBlIHsgQ2FsZW5kYXJGaWx0ZXJzIH0iXSwibmFtZXMiOlsidXNlUXVlcnkiLCJzdXBhYmFzZSIsImZldGNoUHJvZHVjdENhbGVuZGFyRGF0YSIsImZpbHRlcnMiLCJxdWVyeSIsImZyb20iLCJzZWxlY3QiLCJub3QiLCJjZXJ0aWZpY2F0aW9uSWQiLCJkYXRhIiwic3VwcGxpZXJJZHMiLCJlcnJvciIsImNlcnRFcnJvciIsImVxIiwidmFsaWRTdXBwbGllcklkcyIsIm1hcCIsInMiLCJzdXBwbGllcl9pZCIsImxlbmd0aCIsImluIiwic2VhcmNoVGVybSIsImlsaWtlIiwiY2F0ZWdvcnkiLCJzaXplT3B0aW9uIiwicHJvY2Vzc2VkIiwiTWFwIiwiZm9yRWFjaCIsIml0ZW0iLCJwcm9kdWN0SWQiLCJwcm9kdWN0X3BhY2thZ2luZ19zcGVjcyIsInByb2R1Y3RzIiwiaWQiLCJwcm9kdWN0TmFtZSIsIm5hbWUiLCJjb3VudHJ5Iiwic3VwcGxpZXJzIiwia2V5IiwiaGFzIiwic2V0IiwicHJvZHVjdF9pZCIsInByb2R1Y3RfbmFtZSIsImF2YWlsYWJsZV9tb250aHMiLCJlbnRyeSIsImdldCIsIm5ld01vbnRocyIsImZpbHRlciIsIm1vbnRoIiwiaW5jbHVkZXMiLCJwdXNoIiwic3VwcGxpZXIiLCJmaW5kIiwic3BlY3MiLCJwYWNrYWdpbmdfbGFiZWwiLCJwYWNrYWdpbmdfb3B0aW9ucyIsImxhYmVsIiwic2l6ZV9uYW1lIiwic2l6ZV9vcHRpb25zIiwiQXJyYXkiLCJ2YWx1ZXMiLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwidXNlUHJvZHVjdENhbGVuZGFyIiwicXVlcnlLZXkiLCJxdWVyeUZuIiwic3RhbGVUaW1lIiwidXNlUmFuZG9tUHJvZHVjdHMiLCJsaW1pdCIsInAiLCJ1c2VQcm9kdWN0Q2F0ZWdvcmllcyIsImNhdGVnb3JpZXMiLCJTZXQiLCJ1c2VTaXplT3B0aW9ucyIsIm9yZGVyIiwidXNlQWN0aXZlQ2VydGlmaWNhdGlvbnMiLCJ1bmlxdWVDZXJ0aWZpY2F0aW9ucyIsImNlcnRpZmljYXRpb25zIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/use-product-calendar.ts\n"));

/***/ })

});